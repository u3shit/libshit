# -*- mode: python -*-

def options(ctx):
    grp = ctx.get_option_group('configure options')
    grp.add_option('--host-lua', action='store', default=None,
                   help='System lua 5.1/5.2 + bitop or luajit or ljx')
    grp.add_option('--lua-dll', action='store_true', default=None,
                   help='Compile lua as dll (Windows only)')
    ctx.load('gas')

def configure(ctx):
    ctx.add_os_flags('LUACFLAGS')
    variant = ctx.variant
    host_variant = variant + '_host'

    if ctx.env['COMPILER_CXX'] != 'msvc':
        ctx.env.append_value('CFLAGS_LJX', '-fexceptions')
    else:
        ctx.env.LUA_DLL = ctx.options.lua_dll

    if ctx.options.host_lua:
        ctx.find_program(ctx.options.host_lua,
                         var='LUA',
                         environ={'PATH': ctx.environ['PATH']})
    else:
        ctx.setenv(variant + '_host')
        ctx.check_cc(lib='m', mandatory=False)
        ctx.setenv(variant)

    if ctx.env.CROSS:
        configure_ljx(ctx, host_variant, host_variant, '_HOST')
    configure_ljx(ctx, variant, host_variant, '')

    ctx.setenv(variant)
    host_env = ctx.all_envs[host_variant]
    ctx.env.LJX_CROSS = ctx.env.CROSS and \
                        (ctx.env.DASM_ARCH != host_env.DASM_ARCH or \
                         ctx.env.DASM_DEFINES != host_env.DASM_DEFINES or \
                         host_env.CFLAGS_BUILDVM != host_env.CFLAGS_BUILDVM_HOST or \
                         host_env.DEFINES_BUILDVM != host_env.DEFINES_BUILDVM_HOST)
    ctx.msg('Checking if cross compiling ljx',
            ctx.env.LJX_CROSS and 'yes' or 'no',
            color = ctx.env.LJX_CROSS and 'GREEN' or 'YELLOW')

def configure_ljx(ctx, variant, host_variant, suf):
    ctx.setenv(variant)

    if ctx.env['COMPILER_CXX'] != 'msvc':
        ctx.load('gas')

    if ctx.env.DEST_OS == 'linux':
        ctx.check_cc(lib='dl')
        ctx.check_cc(lib='readline')
    ctx.check_cc(lib='m', mandatory=False)

    # preprocess lj_arch.h
    ctx.start_msg('Checking for ljx config')
    cmd = [] # python, why u no have Array#flatten?
    cmd += ctx.env.CC
    cmd += ctx.env.CPPFLAGS
    cmd += ctx.env.CFLAGS
    cmd += ['-E', ctx.path.find_node('ljx/src/lj_arch.h').abspath() ]
    if ctx.env['COMPILER_CXX'] == 'msvc': cmd += ['-Xclang', '-dM']
    else: cmd += ['-dM']
    try:
        out = ctx.cmd_and_log(cmd)
    except Exception:
        ctx.end_msg(False)
        raise

    import re
    reg = re.compile('^#define ([^ ]+) (.*)$')
    macros = dict(map(lambda l: reg.match(l).groups(), out.splitlines()))

    # dasm defines/arch
    dasm_defs = [
        'P'+macros['LJ_ARCH_BITS'],
        'VER='+macros.get('LJ_ARCH_VERSION', ''),
    ]
    if macros.get('LJ_LE', 0) == '1':             dasm_defs += ['ENDIAN_LE']
    else:                                         dasm_defs += ['ENDIAN_BE']
    if macros.get('LJ_HASJIT', 0) == '1':         dasm_defs += ['JIT']
    if macros.get('LJ_HASFFI', 0) == '1':         dasm_defs += ['FFI']
    if macros.get('LJ_DUALNUM', 0) == '1':        dasm_defs += ['DUALNUM']
    if macros.get('LJ_ARCH_HASFPU', 0) == '1':    dasm_defs += ['FPU']
    if macros.get('LJ_ABI_SOFTFP', 0) != '1':     dasm_defs += ['HFABI']
    if macros.get('LJ_NO_UNWIND', 0) == '1':      dasm_defs += ['NO_UNWIND']
    if macros.get('LJ_ARCH_SQRT', 0) == '1':      dasm_defs += ['SQRT']
    if macros.get('LJ_ARCH_ROUND', 0) == '1':     dasm_defs += ['ROUND']
    if macros.get('LJ_ARCH_PPC32ON64', 0) == '1': dasm_defs += ['GPR64']
    if ctx.env.DEST_OS == 'win32' or ctx.env.DEST_OS == 'win64':
        dasm_defs += ['WIN']
    # ios, ps3 checks removed

    dasm_arch = None
    if macros.get('LJ_TARGET_X86', None):        ljarch = dasm_arch = 'x86'
    if macros.get('LJ_TARGET_X64', None):
        _ =                                      ljarch = dasm_arch = 'x64'
        if macros.get('LJ_FR2', 0) != '1':                dasm_arch = 'x86'
    if macros.get('LJ_TARGET_ARM', None):        ljarch = dasm_arch = 'arm'
    if macros.get('LJ_TARGET_ARM64', None):      ljarch = dasm_arch = 'arm64'
    if macros.get('LJ_TARGET_PPC', None):        ljarch = dasm_arch = 'ppc'
    if macros.get('LJ_TARGET_MIPS', None):
        if macros.get('LJ_TARGET_MIPS64', None): ljarch = dasm_arch = 'mips64'
        else:                                    ljarch = dasm_arch = 'mips'
    if not dasm_arch:
        ctx.end_msg(False)
        ctx.fatal('Unsupported ljx architecture')

    ctx.env.DASM_ARCH = dasm_arch
    ctx.env.DASM_DEFINE_ST = ['-D']
    ctx.env.DASM_DEFINES = dasm_defs
    ctx.end_msg('arch: %s/%s, dasm defines: %s' % (ljarch, dasm_arch, ' '.join(dasm_defs)))

    # buildvm flags
    dest_os = ctx.env.DEST_OS
    ctx.setenv(host_variant)
    ctx.env.append_value('CFLAGS_BUILDVM'+suf, '-m' + macros['LJ_ARCH_BITS'])
    ctx.env.append_value('LINKFLAGS_BUILDVM'+suf, '-m' + macros['LJ_ARCH_BITS'])

    # os
    if dest_os == 'win32' or dest_os == 'win64':
        ctx.env.append_value('CFLAGS_BUILDVM'+suf, '-malign-double')
        ctx.env.append_value('DEFINES_BUILDVM'+suf, 'LUAJIT_OS=LUAJIT_OS_WINDOWS')
    elif dest_os == 'linux':
        ctx.env.append_value('DEFINES_BUILDVM'+suf, 'LUAJIT_OS=LUAJIT_OS_LINUX')
    elif dest_os == 'darwin':
        ctx.env.append_value('DEFINES_BUILDVM'+suf, 'LUAJIT_OS=LUAJIT_OS_OSX')
    else:
        ctx.env.append_value('DEFINES_BUILDVM'+suf, 'LUAJIT_OS=LUAJIT_OS_OTHER')

    # architecture specific shit
    if macros.get('LJ_TARGET_PPC', None):
        if macros.get('LJ_LE', 0) == '1':
            ctx.env.append_value('DEFINES_BUILDVM'+suf, 'LJ_ARCH_ENDIAN=LUAJIT_LE')
        else:
            ctx.env.append_value('DEFINES_BUILDVM'+suf, 'LJ_ARCH_ENDIAN=LUAJIT_BE')
    if macros.get('LJ_TARGET_MIPS', None) and macros.get('MIPSEL', None):
        ctx.env.append_value('DEFINES_BUILDVM'+suf, '__MIPSEL__=1')

    ctx.env.append_value('DEFINES_BUILDVM'+suf, [
        'LUAJIT_TARGET=LUAJIT_ARCH_'+ljarch,
        'LJ_ARCH_HASFPU='+macros.get('LJ_ARCH_HASFPU', 0),
        'LJ_ABI_SOFTFP='+macros.get('LJ_ABI_SOFTFP', 0),
    ])
    if macros.get('LJ_NO_UNWIND', 0) == '1':
        ctx.env.append_value('DEFINES_BUILDVM'+suf, 'LUAJIT_NO_UNWIND=1')

    ctx.setenv(variant)

    ctx.env.append_value('DEFINES_LJX',
                         ['LJ_ABIVER=53', 'LUAJIT_ENABLE_LUA53COMPAT'])
    if dest_os != 'win32' and dest_os != 'win64':
        ctx.env.append_value(
            'DEFINES_LJX',
            ['LUA_API=extern __attribute((visibility("default")))'])
    elif ctx.env.LUA_DLL:
        ctx.env.append_value('DEFINES_LJX', ['LUA_BUILD_AS_DLL'])
    if not ctx.options.release:
        ctx.env.append_value('DEFINES_LJX', 'LUA_USE_APICHECK')

def build(ctx):
    host_env = ctx.all_envs[ctx.variant + '_host']

    invalid_files = [
        'ljx/src/host/buildvm_arch.h',
        'ljx/src/lj_bcdef.h',
        'ljx/src/lj_ffdef.h',
        'ljx/src/lj_libdef.h',
        'ljx/src/lj_recdef.h',
        'ljx/src/lj_folddef.h',
    ]
    for f in invalid_files:
        nd = ctx.path.find_node(f)
        if nd:
            ctx.fatal('%s exists, run `make clean` in ext/ljx' % nd.abspath())

    minilua = False
    if not ctx.env.LUA:
        ctx.program(source = 'ljx/src/host/minilua.c',
                    env    = host_env.derive(),
                    uselib = 'M',
                    target = 'minilua')

        tg = ctx.get_tgen_by_name('minilua')
        tg.post()
        ctx.env.LUA = tg.link_task.outputs[0].abspath()
        minilua = True

    if ctx.env.LJX_CROSS:
        old_env = ctx.env
        ctx.env = host_env
        ctx.env.LUA = old_env.LUA
        build_ljx(ctx, minilua, host_env, 'host/', '_HOST')
        ctx.env = old_env

    build_ljx(ctx, minilua, host_env, '', '')

def build_ljx(ctx, minilua, host_env, pref, suf):
    from waflib import Task

    src = ['ljx/dynasm/dynasm.lua', 'ljx/src/vm_%s.dasc' % ctx.env.DASM_ARCH]
    if minilua: src += ['minilua']
    ctx(features = 'dynasm',
        source   = src,
        target   = pref+'buildvm_arch.h')

    src = [
        'ljx/src/host/buildvm_asm.c',
        'ljx/src/host/buildvm_fold.c',
        'ljx/src/host/buildvm_lib.c',
        'ljx/src/host/buildvm_peobj.c',
        'ljx/src/host/buildvm.c',
    ]
    tg = ctx.program(source   = src,
                     env      = host_env.derive(),
                     includes = pref+'. ljx/src',
                     defines  = 'LUAJIT_ENABLE_LUA53COMPAT',
                     uselib   = 'BUILDVM'+suf,
                     target   = pref+'buildvm')
    tg.post()
    buildvm = tg.link_task.outputs[0].abspath()

    tgt = pref+'lj_vm.s'
    if ctx.env.DEST_OS == 'win32' or ctx.env.DEST_OS == 'win64':
        mode = 'peobj'
        tgt  = pref+'lj_vm.obj'
    elif ctx.env.DEST_OS == 'darwin':
        mode = 'machasm'
    else:
        mode = 'elfasm'

    ctx(features = 'buildvm',
        buildvm  = pref+'buildvm',
        mode     = mode,
        target   = tgt)

    src = [
        'ljx/src/lib_base.c',
        'ljx/src/lib_math.c',
        'ljx/src/lib_bit.c',
        'ljx/src/lib_string.c',
        'ljx/src/lib_utf8.c',
        'ljx/src/lib_table.c',
        'ljx/src/lib_io.c',
        'ljx/src/lib_os.c',
        'ljx/src/lib_package.c',
        'ljx/src/lib_debug.c',
        'ljx/src/lib_jit.c',
        'ljx/src/lib_ffi.c',
    ]
    # apparently only `bcdef` (and the obj file above) are different when cross
    # compiling, but generate all of them for extra safety (it's cheap, anyways)
    for mode in ['bcdef', 'ffdef', 'libdef', 'recdef']:
        ctx(features = 'buildvm',
            buildvm  = pref+'buildvm',
            mode     = mode,
            source   = src,
            target   = '%slj_%s.h' % (pref, mode))
    ctx(features = 'buildvm',
        mode     = 'folddef',
        buildvm  = pref+'buildvm',
        source   = 'ljx/src/lj_opt_fold.c',
        target   = pref+'lj_folddef.h')
    # only needed by luajit-ljx?
    ctx(features = 'buildvm',
        mode     = 'vmdef',
        buildvm  = pref+'buildvm',
        source   = src,
        target   = pref+'jit/vmdef.lua')


    ver = 'LJX_VERSION="%s"' % ctx.path.find_node('ljx/.version').read().strip()
    ctx(features        = ctx.env.LUA_DLL and 'c cshlib' or 'c cstlib',
        source          = ['ljx/src/ljamalg.c', tgt],
        includes        = pref+'.',
        export_includes = 'ljx/src',
        defines         = ver,
        uselib          = 'EXT',
        use             = 'LJX DL M',
        target          = pref+'lua53',
        name            = pref+'ljx')

    if ctx.env.LUA_DLL:
        ctx(rule   = 'cp ${SRC} ${TGT}',
            cls_keyword = lambda x: 'cp',
            source = pref+'lua53.dll',
            target = '../../lua53.dll')

    # todo: maybe integrate into stcm-editor
    # only really needed for host
    ctx.program(source  = 'ljx/src/luajit.c',
                use     = pref+'ljx',
                uselib  = 'READLINE',
                defines = [ ver, 'LUA_CREDITS=""' ],
                target  = pref+'luajit-ljx')

from waflib.TaskGen import before_method, after_method, feature, extension
from waflib import Task

@extension('.o', '.obj')
def add_those_o_files(self, node):
    try:
        self.o_files.append(node)
    except AttributeError:
        self.o_files = [node]

@feature('c', 'cxx', 'd', 'fc', 'asm')
@after_method('apply_link')
def add_o(self):
    if getattr(self, 'o_files', None):
        self.link_task.inputs += self.o_files

# tasks
def rule_like(name):
    def x(self):
        self.meths.remove('process_source')
        tsk = self.create_task(name)
        self.task = tsk
        tsk.inputs = self.to_nodes(self.source)

        # from TaskGen.process_rule
        if isinstance(self.target, str):
            self.target = self.target.split()
        if not isinstance(self.target, list):
            self.target = [self.target]
        for x in self.target:
            if isinstance(x, str):
                tsk.outputs.append(self.path.find_or_declare(x))
            else:
                x.parent.mkdir() # if a node was given, create the required folders
                tsk.outputs.append(x)

    x.__name__ = 'rule_like_%s' % name
    feature(name)(x)
    before_method('process_source')(x)

@Task.update_outputs
class dynasm(Task.Task):
    run_str = '${LUA} ${SRC[0].abspath()} ${DASM_DEFINE_ST:DASM_DEFINES} -o ${TGT} ${SRC[1].abspath()}'
    color = 'BLUE'

    def __str__(self):
        return self.inputs[1].relpath()
rule_like('dynasm')

@Task.update_outputs
class buildvm(Task.Task):
    run_str = '${tsk.executable} -m ${gen.mode} -o ${TGT} ${SRC}'
    color = 'BLUE'

    def __str__(self):
        return self.outputs[0].relpath()
rule_like('buildvm')
@feature('buildvm')
@after_method('rule_like_buildvm')
def set_executable(self):
    nd = self.path.find_resource(self.buildvm)

    self.task.executable = nd.abspath()
    self.task.dep_nodes.append(nd)


# task .lua->.h
@Task.update_outputs
class ljx(Task.Task):
    run_str = '${tsk.executable} -bt h ${LUACFLAGS} ${SRC} ${TGT}'
    color = 'BLUE'

@extension('.lua')
def lua_to_h(self, node):
    tsk = self.create_task('ljx', node, node.change_ext('.lua.h'))
    pref = self.bld.env.LJX_CROSS and 'host/' or ''
    ljxtask = self.bld.get_tgen_by_name(pref+'luajit-ljx')
    ljx = ljxtask.link_task.outputs[0]
    bcsav = ljxtask.compiled_tasks[0].inputs[0].find_node('../jit/bcsave.lua')

    tsk.executable = ljx.abspath()
    tsk.env.env = {'LUA_PATH': '%s/?.lua' % bcsav.parent.parent.bldpath()}
    tsk.dep_nodes += [ljx, bcsav]
